options{  DEBUG_PARSER = false;  STATIC = false;}PARSER_BEGIN(Reader)package types.donnees;import java.io.*;import exceptions.LispException;public class Reader{  /** le support de lecture */  protected static java.io.Reader in = new BufferedReader(new InputStreamReader(System.in));  /** lecture d'une S-EXPR au terminal* @return Sexpr : la Sexpr construite.* @throws LispException une erreur de syntaxe*/  public static SExpr read() throws LispException{	Reader parser = new Reader(System.in);    try {		return parser.SEXPRESSION();	} catch (ParseException e) {		throw new LispException();	}  }  /** lecture d'une S-EXPR à partir de la chaîne* @param s : la chaîne* @return Sexpr : la Sexpr construite.* @throws LispException une erreur de syntaxe*/  public static SExpr read(String s) throws LispException{	Reader parser = new Reader(new StringReader(s));    try {		return parser.SEXPRESSION();	} catch (ParseException e) {	  			throw new LispException();	}  }  /** évaluation de la séquence S-EXPRs à partir du fichier s* @param s : le nom du fichier* @return Sexpr : symbole du nom du fichier.* @throws LispException une erreur de lecture*/  public static SExpr importe(String s) throws LispException  {return null;}  private SExpr quote(SExpr arg){     return new SCons(new Symbole("quote"),arg);  }  public static void main(String[] args)  {        try {          System.out.println(read());		//System.out.println(read("'(a b c)"));		} catch (LispException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}  }}PARSER_END(Reader)SKIP :{  " "| "\t"| "\r"| "\n" // attention élimine la notion de fin de ligne| "\u0000"| "\u0001"| "\u0002"| "\u0003"| "\u0004"| "\u0005"| "\u0006"| "\u0007"| "\u0008"| "\u000B"| "\u000C"| "\u000E"| "\u000F"| "\u0010"| "\u0011"| "\u0012"| "\u0013"| "\u0014"| "\u0015"| "\u0016"| "\u0017"| "\u0018"| "\u0019"| "\u001A"| "\u001B"| "\u001C"| "\u001D"| "\u001E"| "\u001F"| "\u007F"}MORE :{  "//" : IN_SL_COMMENT| "/*" : IN_ML_COMMENT}< IN_SL_COMMENT >SPECIAL_TOKEN :{  < SL_COMMENT :    "\n"  | "\r"  | "\r\n" > : DEFAULT}< IN_ML_COMMENT >SPECIAL_TOKEN :{  < ML_COMMENT : "*/" > : DEFAULT}< IN_SL_COMMENT, IN_ML_COMMENT >SKIP :{  < ~[ ] >} // les lexèmes du langageTOKEN:{  < #CARACTERE_SPECIAUX: (["!"-"&"] | ["*"-"/"]) >}TOKEN:{  < #ALPHANUM:(["0"-"~"]) >}//< IN_ATOME >TOKEN :{  < SYMBOLE : (< ALPHANUM >)+ |  			(< CARACTERE_SPECIAUX >)+ |  			((< ALPHANUM >)*(< CARACTERE_SPECIAUX >)*)+ |  			((< CARACTERE_SPECIAUX >)*(< ALPHANUM >)*)+  		   >			}TOKEN :{  < QUOTE : "'" >}TOKEN:{  < P_OUVRANTE: "(" >}TOKEN:{	< P_FERMANTE: ")" >}// les règles de grammaire de ce langageSExpr SEXPRESSIONS() :{SExpr s1=null;}{  (s1=SEXPR())* <EOF>{return s1;}}SExpr SEXPRESSION() :{SExpr s1;}{  s1=SEXPR(){return s1;}}SExpr SEXPR():{SExpr s1;}{  		s1=ATOME(){return s1;} 	|	< QUOTE > s1=SEXPR() {return quote(s1);}    |	< P_OUVRANTE > s1=LISTE() < P_FERMANTE >{return s1;}}SExpr LISTE():{SExpr s1,s2;}{    	s1=SEXPR() s2=LISTE(){return new SCons(s1,s2);}  	|	{return Nil.NIL;}	} SExpr ATOME():{Token t;}{  t=<SYMBOLE>{return new Symbole(t.image);}}